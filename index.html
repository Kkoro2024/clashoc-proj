<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale Battle System (Firebase + Local Test Mode)</title>

    <!-- Firebase V8 SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>

    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Bangers Font -->
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">

    <style>
        * { box-sizing: border-box; }
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: linear-gradient(180deg, #111 0%, #333 100%); color: white; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; padding-top: 10px; user-select: none; }
        .game-screen { width: 95%; max-width: 450px; background-color: #1a1a1a; border: 5px solid #ffcc00; border-radius: 15px; padding: 10px; box-shadow: 0 0 30px rgba(0, 0, 0, 0.7); }
        .top-bar { display: flex; justify-content: space-between; align-items: center; padding: 8px; background-color: #2c2c2c; border-radius: 10px; margin-bottom: 10px; }
        .resource { display: flex; align-items: center; background-color: #3b3b3b; padding: 5px 12px; border-radius: 20px; font-size: 14px; border: 1px solid #555; }
        .resource i { margin-right: 5px; color: #ffcc00; }
        .resource span { font-weight: bold; color: white; text-shadow: 1px 1px 2px #000; }
        .main-content { background: linear-gradient(180deg, #5c381c 0%, #a0522d 100%); border: 4px solid #4d2b16; border-radius: 10px; padding: 15px; text-align: center; min-height: 200px; }
        .main-content h2 { font-family: 'Bangers', cursive; font-size: 2.5em; color: #fff; text-shadow: 4px 4px 0 #000, -2px -2px 0 #b38b00; margin: 0 0 10px 0; }
        .arena-info { background-color: rgba(0, 0, 0, 0.4); padding: 10px; border-radius: 5px; margin-bottom: 15px; }
        .battle-container { display: flex; flex-direction: column; height: 100%; }
        .arena-map { position: relative; width: 100%; height: 500px; background: linear-gradient(180deg, #4a90e2 0%, #87ceeb 50%, #90ee90 50%, #228b22 100%); border: 3px solid #8b4513; border-radius: 8px; overflow: hidden; margin-bottom: 10px; }
        .river { position: absolute; top: 50%; left: 0; right: 0; height: 30px; transform: translateY(-50%); background: linear-gradient(90deg, #1e90ff, #00bfff, #1e90ff); border-top: 2px solid #104e8b; border-bottom: 2px solid #104e8b; z-index: 1; }
        .tower { position: absolute; width: 50px; height: 60px; background: linear-gradient(180deg, #8b4513, #654321); border: 2px solid #000; border-radius: 5px 5px 0 0; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 3px; z-index: 2; }
        .tower::before { content: ''; position: absolute; top: -8px; width: 30px; height: 15px; background: #c41e3a; border: 2px solid #000; border-radius: 3px; }
        .tower.blue::before { background: #4169e1; }
        .tower-health { font-size: 10px; font-weight: bold; color: white; background: rgba(0,0,0,0.6); padding: 2px 4px; border-radius: 3px; margin-top: 8px; }
        .tower.opponent-king { top: 10px; left: 50%; transform: translateX(-50%); }
        .tower.opponent-left { top: 80px; left: 15px; }
        .tower.opponent-right { top: 80px; right: 15px; }
        .tower.player-king { bottom: 10px; left: 50%; transform: translateX(-50%); }
        .tower.player-left { bottom: 80px; left: 15px; }
        .tower.player-right { bottom: 80px; right: 15px; }
        
        /* Tower targeting styles */
        .tower.targetable { cursor: pointer; transition: all 0.2s ease; }
        .tower.targetable:hover { transform: scale(1.1); box-shadow: 0 0 20px rgba(255, 255, 0, 0.8); }
        .tower.targeted { box-shadow: 0 0 15px rgba(0, 255, 0, 0.8); border-color: #00ff00; }
        .tower.opponent-king.targetable:hover { transform: translateX(-50%) scale(1.1); }
        .tower.player-king.targetable:hover { transform: translateX(-50%) scale(1.1); }
        .unit { position: absolute; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid #000; transition: all 0.1s; z-index: 3; }
        .unit.player-unit { background: linear-gradient(135deg, #4169e1, #1e90ff); }
        .unit.opponent-unit { background: linear-gradient(135deg, #dc143c, #ff6347); }
        .unit-hp { position: absolute; bottom: -15px; left: 50%; transform: translateX(-50%); font-size: 9px; background: rgba(0,0,0,0.8); padding: 1px 4px; border-radius: 3px; white-space: nowrap; }
        .player-status { display: flex; justify-content: space-between; align-items: center; background: rgba(0, 0, 0, 0.5); padding: 8px; border-radius: 5px; margin-bottom: 8px; }
        .player-status.opponent { flex-direction: row-reverse; }
        .player-name { font-size: 14px; font-weight: bold; }
        .elixir-display { display: flex; align-items: center; gap: 5px; font-size: 16px; font-weight: bold; color: #ff00ff; }
        .elixir-bar { display: flex; gap: 3px; }
        .elixir-drop { width: 15px; height: 15px; background: linear-gradient(135deg, #ff00ff, #8b008b); border-radius: 50%; border: 1px solid #000; }
        .elixir-drop.empty { background: #333; opacity: 0.5; }
        .card-hand { display: flex; justify-content: space-around; gap: 8px; padding: 10px; background: rgba(0, 0, 0, 0.6); border-radius: 8px; }
        .card { width: 70px; background: linear-gradient(180deg, #2c3e50, #34495e); border: 3px solid #f39c12; border-radius: 8px; padding: 8px 4px; cursor: pointer; transition: all 0.2s; position: relative; }
        .card:hover:not(.disabled) { transform: translateY(-10px); box-shadow: 0 8px 16px rgba(243, 156, 18, 0.5); }
        .card.selected { border-color: #2ecc71; box-shadow: 0 0 15px #2ecc71; }
        .card.disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; }
        .card-icon { font-size: 28px; margin-bottom: 5px; }
        .card-name { font-size: 10px; font-weight: bold; margin-bottom: 3px; }
        .card-cost { position: absolute; top: -8px; right: -8px; background: linear-gradient(135deg, #ff00ff, #8b008b); color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid #000; }
        .battle-button { color: white; padding: 12px 30px; border: 3px solid #ffcc00; border-radius: 8px; font-size: 18px; font-weight: bold; text-transform: uppercase; cursor: pointer; transition: all 0.1s; width: 100%; margin-top: 10px; }
        .battle-tab-button { background: linear-gradient(180deg, #ff4d4d 0%, #cc0000 100%); box-shadow: 0 6px #990000; font-size: 22px; padding: 15px; }
        .forfeit-button { background: linear-gradient(180deg, #555, #333); box-shadow: 0 4px #222; font-size: 14px; padding: 8px; }
        .battle-button:active:not(:disabled) { transform: translateY(3px); }
        .battle-button:disabled { opacity: 0.6; cursor: not-allowed; }
        .bottom-nav { display: flex; justify-content: space-around; background-color: #3b3b3b; padding: 5px 0; border-radius: 10px; margin-top: 10px; box-shadow: 0 -3px #222; }
         .nav-button { flex: 1; text-align: center; padding: 10px 5px; font-size: 11px; cursor: pointer; border-top: 4px solid transparent; transition: all 0.2s; color: #aaa; text-transform: uppercase; display: flex; flex-direction: column; align-items: center; justify-content: center; }
         .nav-button i { margin-bottom: 2px; font-size: 14px; }
         .nav-button.active { border-top: 4px solid #ffcc00; color: #ffcc00; font-weight: bold; }
        .game-timer { position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.8); padding: 5px 10px; border-radius: 5px; font-weight: bold; font-size: 16px; z-index: 10; }
        .deploy-indicator { position: absolute; width: 40px; height: 40px; border: 3px dashed #2ecc71; border-radius: 50%; pointer-events: none; display: none; animation: pulse 0.5s infinite; z-index: 10; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.2); opacity: 0.4; } }
        .cards-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; padding: 10px; }
        .card-detail { background: linear-gradient(180deg, #2c3e50, #34495e); border: 3px solid #f39c12; border-radius: 10px; padding: 15px; text-align: center; }
        .card-detail.locked { border-color: #555; opacity: 0.6; }
        .card-detail-icon { font-size: 48px; margin-bottom: 10px; }
        .card-detail-name { font-size: 16px; font-weight: bold; margin-bottom: 5px; }
        .card-detail-cost { color: #ff00ff; font-weight: bold; margin-bottom: 8px; }
        .card-detail-desc { font-size: 11px; color: #ccc; line-height: 1.3; margin-bottom: 8px; }
        .card-detail-stats { font-size: 10px; color: #aaa; margin-top: 5px; }
        .unlock-requirement { background: rgba(0, 0, 0, 0.5); padding: 5px; border-radius: 5px; font-size: 11px; color: #ffcc00; margin-top: 8px; }
        
        /* XP System Styles */
        .level-resource { position: relative; flex-direction: column; align-items: center; gap: 3px; }
        .xp-mini-bar { width: 100%; height: 4px; background: rgba(0, 0, 0, 0.3); border-radius: 2px; overflow: hidden; margin-top: 2px; }
        .xp-mini-progress { height: 100%; background: linear-gradient(90deg, #4ecdc4, #44a08d); border-radius: 2px; width: 0%; transition: width 0.5s ease; }
        
        .level-up-notification { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); 
            background: linear-gradient(135deg, #ff6b6b, #ffa500); color: white; 
            padding: 30px; border-radius: 15px; text-align: center; 
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5); z-index: 1000; 
            transition: transform 0.5s ease; font-family: 'Bangers', cursive;
        }
        .level-up-notification.show { transform: translate(-50%, -50%) scale(1); }
        .level-up-notification h2 { font-size: 2em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); }
        .level-up-notification p { font-size: 1.2em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); }
        
        .xp-gain-animation { 
            position: fixed; color: #4ecdc4; font-weight: bold; font-size: 18px; 
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); z-index: 999; 
            pointer-events: none; animation: xpGainFloat 2s ease-out forwards;
        }
        @keyframes xpGainFloat { 
            0% { opacity: 1; transform: translateY(0); } 
            100% { opacity: 0; transform: translateY(-50px); } 
        }
        
        /* Lobby System Styles */
        .lobby-container { padding: 20px; }
        .lobby-section { margin-bottom: 30px; }
        .lobby-section h3 { color: #ffcc00; margin-bottom: 15px; font-size: 1.3em; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); }
        
        .create-match { background: linear-gradient(135deg, #2c3e50, #34495e); padding: 20px; border-radius: 10px; border: 2px solid #f39c12; margin-bottom: 20px; }
        .create-match h4 { color: #f39c12; margin-bottom: 15px; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; color: #ecf0f1; margin-bottom: 5px; font-weight: bold; }
        .input-group input { width: 100%; padding: 10px; border: 2px solid #555; border-radius: 5px; background: #2c2c2c; color: white; font-size: 14px; }
        .input-group input:focus { border-color: #f39c12; outline: none; }
        
        .search-matches { background: linear-gradient(135deg, #27ae60, #2ecc71); padding: 20px; border-radius: 10px; border: 2px solid #27ae60; margin-bottom: 20px; }
        .search-matches h4 { color: #2ecc71; margin-bottom: 15px; }
        .search-bar { display: flex; gap: 10px; margin-bottom: 15px; }
        .search-bar input { flex: 1; padding: 10px; border: 2px solid #555; border-radius: 5px; background: #2c2c2c; color: white; }
        .search-bar button { padding: 10px 20px; background: linear-gradient(135deg, #3498db, #2980b9); border: none; border-radius: 5px; color: white; font-weight: bold; cursor: pointer; }
        .search-bar button:hover { background: linear-gradient(135deg, #2980b9, #1f618d); }
        
        .matches-list { max-height: 300px; overflow-y: auto; }
        .match-item { background: linear-gradient(135deg, #34495e, #2c3e50); padding: 15px; margin-bottom: 10px; border-radius: 8px; border: 2px solid #555; display: flex; justify-content: space-between; align-items: center; transition: all 0.3s ease; }
        .match-item:hover { border-color: #f39c12; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); }
        .match-info h5 { color: #ecf0f1; margin: 0 0 5px 0; font-size: 1.1em; }
        .match-info p { color: #bdc3c7; margin: 0; font-size: 0.9em; }
        .match-actions { display: flex; gap: 10px; }
        .join-button { padding: 8px 16px; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 5px; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; }
        .join-button:hover { background: linear-gradient(135deg, #c0392b, #a93226); transform: scale(1.05); }
        .join-button:disabled { background: #7f8c8d; cursor: not-allowed; transform: none; }
        
        .no-matches { text-align: center; color: #7f8c8d; padding: 20px; font-style: italic; }
        .loading { text-align: center; color: #f39c12; padding: 20px; }
        
        .match-status { display: inline-block; padding: 4px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; }
         .match-status.waiting { background: #f39c12; color: #2c3e50; }
         .match-status.full { background: #e74c3c; color: white; }
         .match-status.in-progress { background: #27ae60; color: white; }
         
         /* Simple lobby styles */
         .join-match { text-align: center; }
         .join-match .input-group { display: flex; gap: 10px; margin: 20px 0; }
         .join-match input { flex: 1; padding: 12px; border: 2px solid #555; border-radius: 8px; background: #333; color: white; font-size: 16px; }
         .join-match input:focus { border-color: #ffcc00; outline: none; }
         .help-text { color: #aaa; font-size: 14px; margin-top: 10px; }
         .refresh-btn { background: #555; border: none; color: white; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-top: 10px; }
         .refresh-btn:hover { background: #666; }
         .your-match { background: #27ae60; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
         .in-match { background: #3498db; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
         .full-match { background: #e74c3c; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
         
         /* Mobile responsive for bottom nav */
         @media (max-width: 768px) {
             .bottom-nav { flex-wrap: wrap; }
             .nav-button { flex: 1; min-width: 80px; font-size: 10px; padding: 8px 2px; }
             .nav-button i { display: block; margin-bottom: 2px; }
             .join-match .input-group { flex-direction: column; }
         }
    </style>
</head>
<body>
    <div class="game-screen">
        <div class="top-bar">
            <div class="resource"><i class="fas fa-trophy"></i> <span id="trophyCount">0</span></div>
            <div class="resource level-resource">
                <i class="fas fa-star"></i> 
                <span id="levelDisplay">1</span>
                <div class="xp-mini-bar">
                    <div class="xp-mini-progress" id="xpMiniProgress"></div>
                </div>
            </div>
            <div class="resource"><i class="fas fa-coins"></i> <span id="coinCount">500</span></div>
        </div>

        <div id="mainContent" class="main-content">
            <div class="arena-info">
                <h2>Royal Arena</h2>
                <p>Welcome to the battlefield!</p>
            </div>
            <button id="battleButton" class="battle-button battle-tab-button"><i class="fas fa-swords"></i> Battle!</button>
        </div>

        <div id="bottomNav" class="bottom-nav">
            <div class="nav-button active" data-content="battle"><i class="fas fa-home"></i> Battle</div>
            <div class="nav-button" data-content="lobby"><i class="fas fa-users"></i> Lobby</div>
            <div class="nav-button" data-content="cards"><i class="fas fa-box"></i> Cards</div>
        </div>
        
        <!-- Level Up Notification -->
        <div class="level-up-notification" id="levelUpNotification">
            <h2>ðŸŽ‰ Level Up! ðŸŽ‰</h2>
            <p>You reached level <span id="newLevel"></span>!</p>
        </div>
    </div>

    <script>
        // ---------- Firebase setup ----------
        const firebaseConfig = {
            apiKey: "AIzaSyAl6M4MFeEUgbDToq_KfJuPJTEJmvuR_u4",
            authDomain: "clash-68614.firebaseapp.com",
            databaseURL: "https://clash-68614-default-rtdb.firebaseio.com",
            projectId: "clash-68614",
            storageBucket: "clash-68614.firebase-storage.app",
            messagingSenderId: "374298608837",
            appId: "1:374298608837:web:5f325abdd53b3e94cedcac"
        };

        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const myPlayerID = 'player_' + Math.random().toString(36).substring(2, 9);
        const myPlayerName = `Guest-${myPlayerID.substring(7)}`;
        const matchmakingRef = database.ref('matchmaking');
        const matchesRef = database.ref('matches');
        const lobbiesRef = database.ref('lobbies');

        // ---------- UI refs & state ----------
        const navButtons = document.querySelectorAll('.nav-button');
        const mainContent = document.getElementById('mainContent');
        const bottomNav = document.getElementById('bottomNav');

        let currentMatchID = null;
        let isPlayerA = null;
        let opponentID = null;
        let gameListenerActive = false;
        let elixirInterval = null;
        let gameTickInterval = null;
        let myElixir = 5;
        let selectedCard = null;
        let myDeck = [];

        // Local-only units (used when no Firebase match is active) - helpful for testing
        let localUnits = {};

        // ---------- CARD DEFINITIONS ----------
        const CARDS = {
            knight: { name: 'Knight', icon: 'ðŸ—¡ï¸', cost: 3, hp: 1400, damage: 75, speed: 1, range: 'melee', type: 'troop', behavior: 'ground_melee', targetPriority: 'any', desc: 'A tough melee fighter with high HP.', unlockLevel: 1 },
            archer: { name: 'Archer', icon: 'ðŸ¹', cost: 3, hp: 252, damage: 60, speed: 0.5, range: 'ranged', type: 'troop', behavior: 'ranged_attacker', targetPriority: 'troops', attackRange: 5, desc: 'Ranged attacker that fires arrows.', unlockLevel: 1 },
            goblin: { name: 'Goblin', icon: 'ðŸ‘º', cost: 2, hp: 147, damage: 80, speed: 1.8, range: 'melee', type: 'troop', behavior: 'ground_melee', targetPriority: 'any', desc: 'Fast and cheap melee unit.', unlockLevel: 1 },
            cannon: { name: 'Cannon', icon: 'ðŸŽ¯', cost: 3, hp: 510, damage: 60, lifetime: 30, range: 'ranged', type: 'building', behavior: 'defensive_building', targetPriority: 'troops', attackRange: 6, desc: 'Defensive building that stays put.', unlockLevel: 1 },
            giant: { name: 'Giant', icon: 'ðŸ§Ÿ', cost: 5, hp: 3275, damage: 120, speed: 0.6, range: 'melee', type: 'troop', behavior: 'building_targeting', targetPriority: 'buildings', desc: 'Massive HP tank that only targets buildings.', unlockLevel: 2 },
            skeletons: { name: 'Skeletons', icon: 'ðŸ’€', cost: 1, hp: 67, damage: 67, speed: 1.5, range: 'melee', type: 'troop', behavior: 'ground_melee', targetPriority: 'any', spawnCount: 3, desc: 'Summons 3 fragile but fast skeletons.', unlockLevel: 1 }
        };

        let playerData = { 
            trophies: 0, 
            level: 1, 
            xp: 0, 
            totalXp: 0, 
            levelsGained: 0,
            coins: 500, 
            wins: 0, 
            losses: 0, 
            unlockedCards: ['knight', 'archer', 'goblin', 'cannon', 'skeletons'] 
        };

        // ---------- XP System Functions ----------
        const getXpForLevel = (level) => Math.floor(100 * Math.pow(1.2, level - 1));
        const getLevelTitle = (level) => {
            const titles = ["Novice", "Apprentice", "Journeyman", "Expert", "Master", "Grandmaster", "Legend", "Mythic", "Transcendent", "Divine"];
            const titleIndex = Math.min(Math.floor((level - 1) / 5), titles.length - 1);
            return titles[titleIndex];
        };

        const gainXP = (amount) => {
            playerData.xp += amount;
            playerData.totalXp += amount;
            
            // Show XP gain animation
            showXPGainAnimation(amount);
            
            // Check for level up
            while (playerData.xp >= getXpForLevel(playerData.level)) {
                levelUp();
            }
            
            updateResourceDisplay();
            savePlayerData();
        };

        const levelUp = () => {
            playerData.xp -= getXpForLevel(playerData.level);
            playerData.level++;
            playerData.levelsGained++;
            
            // Unlock new cards based on level
            unlockCardsForLevel(playerData.level);
            
            showLevelUpNotification();
        };

        const unlockCardsForLevel = (level) => {
            const newCards = [];
            Object.keys(CARDS).forEach(cardId => {
                if (CARDS[cardId].unlockLevel <= level && !playerData.unlockedCards.includes(cardId)) {
                    playerData.unlockedCards.push(cardId);
                    newCards.push(CARDS[cardId].name);
                }
            });
            
            if (newCards.length > 0) {
                setTimeout(() => {
                    alert(`ðŸŽ‰ New cards unlocked: ${newCards.join(', ')}!`);
                }, 2000);
            }
        };

        const showXPGainAnimation = (amount) => {
            const animation = document.createElement('div');
            animation.className = 'xp-gain-animation';
            animation.textContent = `+${amount} XP`;
            animation.style.left = '50%';
            animation.style.top = '50%';
            animation.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(animation);
            
            setTimeout(() => animation.remove(), 2000);
        };

        const showLevelUpNotification = () => {
            const notification = document.getElementById('levelUpNotification');
            const newLevelSpan = document.getElementById('newLevel');
            
            newLevelSpan.textContent = playerData.level;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        };

        const loadPlayerData = () => { 
            const saved = localStorage.getItem('clashPlayerData'); 
            if (saved) {
                const parsed = JSON.parse(saved);
                playerData = { ...playerData, ...parsed };
            }
            updateResourceDisplay(); 
        };
        const savePlayerData = () => { localStorage.setItem('clashPlayerData', JSON.stringify(playerData)); updateResourceDisplay(); };
        const updateResourceDisplay = () => { 
            document.getElementById('trophyCount').textContent = playerData.trophies; 
            document.getElementById('levelDisplay').textContent = playerData.level; 
            document.getElementById('coinCount').textContent = playerData.coins;
            
            // Update XP progress bar
            const xpNeeded = getXpForLevel(playerData.level);
            const xpProgress = (playerData.xp / xpNeeded) * 100;
            const xpMiniProgress = document.getElementById('xpMiniProgress');
            if (xpMiniProgress) {
                xpMiniProgress.style.width = `${xpProgress}%`;
            }
        };

        const generateDeck = () => { const unlocked = playerData.unlockedCards.map(id => ({ id, ...CARDS[id] })); const shuffled = unlocked.sort(() => Math.random() - 0.5); return shuffled.slice(0, Math.min(4, unlocked.length)); };

        // ---------- GAME VIEW ----------
        const startGameView = (matchID, playerA, playerB) => {
            currentMatchID = matchID;
            isPlayerA = (myPlayerID === playerA);
            opponentID = isPlayerA ? playerB : playerA;

            myDeck = generateDeck();
            myElixir = 5; selectedCard = null;

            bottomNav.style.display = 'none';

            mainContent.innerHTML = `
                <div class="battle-container">
                    <div class="player-status opponent">
                        <div class="player-name">ðŸ”´ Opponent</div>
                    </div>
                    <div class="arena-map" id="arenaMap">
                        <div class="game-timer" id="gameTimer">3:00</div>
                        <div class="deploy-indicator" id="deployIndicator"></div>
                        <div class="river"></div>
                        <div class="tower opponent-king blue"><div class="tower-health" id="tower-opponent-king">2534</div></div>
                        <div class="tower opponent-left blue"><div class="tower-health" id="tower-opponent-left">1420</div></div>
                        <div class="tower opponent-right blue"><div class="tower-health" id="tower-opponent-right">1420</div></div>
                        <div class="tower player-king"><div class="tower-health" id="tower-player-king">2534</div></div>
                        <div class="tower player-left"><div class="tower-health" id="tower-player-left">1420</div></div>
                        <div class="tower player-right"><div class="tower-health" id="tower-player-right">1420</div></div>
                    </div>
                    <div class="player-status">
                        <div class="player-name">ðŸ”µ You</div>
                        <div class="elixir-display">
                            <div class="elixir-bar" id="elixirBar"></div>
                            <span id="myElixir">5</span>
                        </div>
                    </div>
                    <div class="card-hand" id="cardHand"></div>
                    <button class="battle-button forfeit-button" id="forfeitButton"><i class="fas fa-flag"></i> Forfeit</button>
                </div>
            `;

            renderCardHand(); updateElixirDisplay(); setupMapClickHandler(); setupTowerTargeting();
            document.getElementById('forfeitButton').addEventListener('click', () => endGame("Forfeited", false));

            startElixirGeneration(); listenForGameState(matchID); startGameTick();
        };

        const renderCardHand = () => {
            const cardHand = document.getElementById('cardHand');
            if (!cardHand) return;
            cardHand.innerHTML = myDeck.map((card, index) => `
                <div class="card ${myElixir < card.cost ? 'disabled' : ''}" data-card-index="${index}">
                    <div class="card-cost">${card.cost}</div>
                    <div class="card-icon">${card.icon}</div>
                    <div class="card-name">${card.name}</div>
                </div>
            `).join('');

            document.querySelectorAll('.card').forEach(cardEl => {
                cardEl.addEventListener('click', () => {
                    const index = parseInt(cardEl.dataset.cardIndex);
                    const card = myDeck[index];
                    if (myElixir >= card.cost) {
                        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
                        if (selectedCard === index) { selectedCard = null; } else { selectedCard = index; cardEl.classList.add('selected'); }
                    }
                });
            });
        };

        const updateElixirDisplay = () => {
            const elixirBar = document.getElementById('elixirBar');
            const myElixirSpan = document.getElementById('myElixir');
            if (elixirBar && myElixirSpan) { elixirBar.innerHTML = Array(10).fill(0).map((_, i) => `<div class="elixir-drop ${i < myElixir ? '' : 'empty'}"></div>`).join(''); myElixirSpan.textContent = myElixir; }
            document.querySelectorAll('.card').forEach((cardEl, index) => { const card = myDeck[index]; if (myElixir >= card.cost) cardEl.classList.remove('disabled'); else cardEl.classList.add('disabled'); });
        };

        const startElixirGeneration = () => { if (elixirInterval) clearInterval(elixirInterval); elixirInterval = setInterval(() => { if (myElixir < 10) { myElixir++; updateElixirDisplay(); } }, 2800); };

        const setupMapClickHandler = () => {
            const arenaMap = document.getElementById('arenaMap');
            if (!arenaMap) return;
            arenaMap.addEventListener('click', (e) => {
                if (selectedCard === null) return; const card = myDeck[selectedCard]; if (myElixir < card.cost) return; const rect = arenaMap.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top; if (y < rect.height * 0.5) return; deployCard(card, x, y, rect.width, rect.height);
            });
        };

        const setupTowerTargeting = () => {
            // Add targetable class to opponent towers
            const opponentTowers = ['tower-opponent-king', 'tower-opponent-left', 'tower-opponent-right'];
            opponentTowers.forEach(towerId => {
                const tower = document.getElementById(towerId);
                if (tower) {
                    tower.classList.add('targetable');
                    tower.addEventListener('click', (e) => {
                        e.stopPropagation();
                        setTowerTarget(towerId);
                    });
                }
            });
        };

        const setTowerTarget = (towerId) => {
            // Clear previous targets
            document.querySelectorAll('.tower.targeted').forEach(t => t.classList.remove('targeted'));
            
            // Set new target
            const tower = document.getElementById(towerId);
            if (tower) {
                tower.classList.add('targeted');
                
                // Update all player units to target this tower
                Object.keys(localUnits).forEach(unitId => {
                    const unit = localUnits[unitId];
                    if (unit && unit.owner === myPlayerID) {
                        // Set manual target for this unit
                        const towerPositions = {
                            'tower-opponent-king': { x: 50, y: 10 },
                            'tower-opponent-left': { x: 15, y: 16 },
                            'tower-opponent-right': { x: 85, y: 16 }
                        };
                        
                        const pos = towerPositions[towerId];
                        if (pos) {
                            unit.manualTarget = {
                                x: pos.x,
                                y: pos.y,
                                towerId: towerId.replace('tower-opponent-', 'playerB-'),
                                type: 'tower'
                            };
                        }
                    }
                });
            }
        };

        // ---------- Deploy cards (supports Firebase match OR local-only testing) ----------
const deployCard = (card, x, y, mapWidth, mapHeight) => {
    const xPercent = (x / mapWidth) * 100; 
    const yPercent = (y / mapHeight) * 100;
    let targetLane = 'king'; 
    if (xPercent < 33) targetLane = 'left'; 
    else if (xPercent > 67) targetLane = 'right';

    // base unit data
    const unitData = {
        cardId: card.id || Object.keys(CARDS).find(key => CARDS[key].name === card.name),
        type: card.type,
        behavior: card.behavior || 'ground_melee',
        targetPriority: card.targetPriority || 'any',
        owner: myPlayerID,
        ownerRole: isPlayerA ? 'playerA' : 'playerB',
        x: xPercent,
        y: yPercent,
        hp: card.hp || 100,
        maxHp: card.hp || 100,
        damage: card.damage || 50,
        speed: card.speed || 0,
        range: card.range,
        attackRange: card.attackRange || 3,
        splashRadius: card.splashRadius || 0,
        targetLane: targetLane,
        isMoving: card.behavior !== 'defensive_building' && card.behavior !== 'siege_building',
        spawnTime: Date.now(),
        lastAttackTime: Date.now(),
        attackSpeed: 1000
    };

    // only add lifetime if defined
    if (card.lifetime !== undefined) {
        unitData.lifetime = card.lifetime;
    }

    if (currentMatchID) {
        const matchRef = matchesRef.child(currentMatchID);
        if (card.spawnCount && card.spawnCount > 1) {
            for (let i = 0; i < card.spawnCount; i++) {
                const offsetX = (Math.random() - 0.5) * 5;
                const offsetY = (Math.random() - 0.5) * 3;
                const spawnUnit = { ...unitData, x: xPercent + offsetX, y: yPercent + offsetY };
                matchRef.child('units').push(spawnUnit);
            }
        } else {
            matchRef.child('units').push(unitData);
        }
    } else {
        // LOCAL testing mode
        if (card.spawnCount && card.spawnCount > 1) {
            for (let i = 0; i < card.spawnCount; i++) {
                const id = 'unit_' + Math.random().toString(36).substring(2, 9);
                const offsetX = (Math.random() - 0.5) * 5;
                const offsetY = (Math.random() - 0.5) * 3;
                localUnits[id] = { ...unitData, x: unitData.x + offsetX, y: unitData.y + offsetY };
            }
        } else {
            const id = 'unit_' + Math.random().toString(36).substring(2, 9);
            localUnits[id] = unitData;
        }
        renderUnits(localUnits);
    }

    myElixir -= card.cost;
    updateElixirDisplay();
    selectedCard = null;
    document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
    
    // Gain XP for deploying cards
    gainXP(2);

    const deployIndicator = document.getElementById('deployIndicator');
    if (deployIndicator) {
        deployIndicator.style.left = x + 'px';
        deployIndicator.style.top = y + 'px';
        deployIndicator.style.display = 'block';
        setTimeout(() => deployIndicator.style.display = 'none', 500);
    }
};

        // ---------- Game state listener (Firebase) ----------
        const listenForGameState = (matchID) => {
            matchesRef.off(); gameListenerActive = true;

            matchesRef.child(matchID).on('value', snapshot => {
                if (!gameListenerActive) return; const match = snapshot.val(); if (!match || match.status !== 'active') { endGame("Match ended", false); return; }

                if (match.towers) {
                    const towerMapping = isPlayerA ? {
                        'playerA-king': 'tower-player-king','playerA-left': 'tower-player-left','playerA-right': 'tower-player-right','playerB-king': 'tower-opponent-king','playerB-left': 'tower-opponent-left','playerB-right': 'tower-opponent-right'
                    } : {
                        'playerB-king': 'tower-player-king','playerB-left': 'tower-player-left','playerB-right': 'tower-player-right','playerA-king': 'tower-opponent-king','playerA-left': 'tower-opponent-left','playerA-right': 'tower-opponent-right'
                    };

                    Object.keys(match.towers).forEach(towerId => {
                        const displayTowerId = towerMapping[towerId]; const towerEl = document.getElementById(displayTowerId); if (towerEl) { towerEl.textContent = Math.ceil(match.towers[towerId]); if (match.towers[towerId] <= 0) { towerEl.textContent = 'ðŸ’€'; towerEl.parentElement.style.opacity = '0.3'; } }
                    });

                    const myKingTower = isPlayerA ? 'playerA-king' : 'playerB-king'; const opponentKingTower = isPlayerA ? 'playerB-king' : 'playerA-king';
                    if ((match.towers[myKingTower] || 0) <= 0) { endGame('ðŸ’€ Defeat! Your King Tower was destroyed!', false); return; }
                    if ((match.towers[opponentKingTower] || 0) <= 0) { endGame('ðŸ‘‘ Victory! Enemy King Tower destroyed!', true); return; }
                }

                renderUnits(match.units || {});

                if (match.startTime) {
                    const elapsed = Math.floor((Date.now() - match.startTime) / 1000); const remaining = Math.max(0, 180 - elapsed); const minutes = Math.floor(remaining / 60); const seconds = remaining % 60; const timerEl = document.getElementById('gameTimer'); if (timerEl) { timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`; } if (remaining === 0) endGame("Time's up!", false);
                }
            });
        };

        // ---------- Render units (works with both Firebase unit object and localUnits) ----------
        const renderUnits = (units) => {
            const arenaMap = document.getElementById('arenaMap'); if (!arenaMap) return; arenaMap.querySelectorAll('.unit').forEach(el => el.remove());
            Object.keys(units).forEach(unitId => {
                const unit = units[unitId]; if (!unit || unit.hp <= 0) return; const unitEl = document.createElement('div'); const isMyUnit = unit.owner === myPlayerID; let displayX = unit.x; let displayY = unit.y; if (!isMyUnit) displayY = 100 - unit.y; unitEl.className = `unit ${isMyUnit ? 'player-unit' : 'opponent-unit'}`; unitEl.style.left = `${displayX}%`; unitEl.style.top = `${displayY}%`; unitEl.style.transform = 'translate(-50%, -50%)'; const cardData = CARDS[unit.cardId]; unitEl.innerHTML = `${cardData ? cardData.icon : 'âš”ï¸'}<div class="unit-hp">${Math.ceil(unit.hp)}</div>`; arenaMap.appendChild(unitEl);
            });
        };

        // ---------- Main game tick: updates Firebase match OR local simulation when no match ----------
        const startGameTick = () => {
            if (gameTickInterval) clearInterval(gameTickInterval);
            gameTickInterval = setInterval(() => {
                if (!currentMatchID) {
                    // Local-only simulation for testing: update localUnits, move them & apply attacks
                    simulateLocalTick(); renderUnits(localUnits); return;
                }

                const matchRef = matchesRef.child(currentMatchID);
                matchRef.once('value', matchSnapshot => {
                    const matchData = matchSnapshot.val(); if (!matchData) return;
                    const units = matchData.units || {};
                    const towers = matchData.towers || {'playerA-king':2534,'playerA-left':1420,'playerA-right':1420,'playerB-king':2534,'playerB-left':1420,'playerB-right':1420};
                    let updates = {}; const now = Date.now();

                    Object.keys(units).forEach(unitId => {
                        const unit = units[unitId]; if (!unit) return;
                        if (unit.hp <= 0) { updates[`units/${unitId}`] = null; return; }
                        if (unit.type === 'building' && unit.lifetime) { const age = (now - unit.spawnTime)/1000; if (age > unit.lifetime) { updates[`units/${unitId}`] = null; return; } }

                        const isPlayerAUnit = unit.ownerRole === 'playerA'; const opponentPrefix = isPlayerAUnit ? 'playerB' : 'playerA';
                        let target = null; let targetType = null;

                        if (unit.behavior === 'defensive_building' || unit.behavior === 'ranged_attacker') { target = findNearestEnemyTroop(unit, units); targetType = 'troop'; }
                        else if (unit.behavior === 'building_targeting') { target = findNearestEnemyTower(unit, towers, opponentPrefix, unit.targetLane); targetType = 'tower'; }
                        else if (unit.behavior === 'ground_melee') {
                            const nearbyTroop = findNearestEnemyTroop(unit, units);
                            if (nearbyTroop && nearbyTroop.distance < 15) { target = nearbyTroop; targetType = 'troop'; }
                            else { target = findNearestEnemyTower(unit, towers, opponentPrefix, unit.targetLane); targetType = 'tower'; }
                        }

                        if (unit.isMoving && unit.speed && target && target.x !== undefined) {
                            const dx = target.x - unit.x; const dy = target.y - unit.y; const distance = Math.sqrt(dx*dx + dy*dy) || 1; const inRange = distance < (unit.attackRange || 3);
                            if (!inRange) { unit.x += (dx / distance) * unit.speed * 0.5; unit.y += (dy / distance) * unit.speed * 0.5; updates[`units/${unitId}/x`] = unit.x; updates[`units/${unitId}/y`] = unit.y; }
                        }

                        if (target && (now - (unit.lastAttackTime || 0)) > (unit.attackSpeed || 1000)) {
                            if (targetType === 'troop' && target.distance < (unit.attackRange || 3)) {
                                const targetUnitId = target.id; const targetUnit = units[targetUnitId]; if (targetUnit && targetUnit.hp > 0) { updates[`units/${targetUnitId}/hp`] = Math.max(0, targetUnit.hp - (unit.damage || 50)); updates[`units/${unitId}/lastAttackTime`] = now; }
                            } else if (targetType === 'tower' && target.distance < (unit.attackRange || 3)) {
                                const towerId = target.towerId; if (towers[towerId] > 0) { updates[`towers/${towerId}`] = Math.max(0, towers[towerId] - (unit.damage || 50)); updates[`units/${unitId}/lastAttackTime`] = now; }
                            }
                        }
                    });

                    if (Object.keys(updates).length > 0) matchRef.update(updates);
                });
            }, 100);
        };

        // ---------- Local simulation tick (used when not connected to a Firebase match) ----------

// ---------- Local simulation tick (used when not connected to a Firebase match) ----------
const simulateLocalTick = () => {
    const now = Date.now();
    const towers = {
        'playerA-king': 2534,
        'playerA-left': 1420,
        'playerA-right': 1420,
        'playerB-king': 2534,
        'playerB-left': 1420,
        'playerB-right': 1420
    };
    const toRemove = [];

    Object.keys(localUnits).forEach(unitId => {
        const unit = localUnits[unitId];
        if (!unit) return;

        if (unit.hp <= 0) { toRemove.push(unitId); return; }
        if (unit.type === 'building' && unit.lifetime) {
            const age = (now - unit.spawnTime) / 1000;
            if (age > unit.lifetime) { toRemove.push(unitId); return; }
        }

        const isPlayerAUnit = unit.ownerRole === 'playerA';
        const opponentPrefix = isPlayerAUnit ? 'playerB' : 'playerA';
        let target = null;
        let targetType = null;
        const units = localUnits;

        // Check for manual target first
        if (unit.manualTarget) {
            const dx = unit.manualTarget.x - unit.x;
            const dy = unit.manualTarget.y - unit.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            target = {
                x: unit.manualTarget.x,
                y: unit.manualTarget.y,
                distance: distance,
                towerId: unit.manualTarget.towerId,
                type: unit.manualTarget.type
            };
            targetType = unit.manualTarget.type;
        } else if (unit.behavior === 'ranged_attacker') {
            // First try to find enemy troops
            const enemyTroop = findNearestEnemyTroop(unit, units);
            if (enemyTroop && enemyTroop.distance < (unit.attackRange || 6)) {
                target = enemyTroop;
                targetType = 'troop';
            } else {
                // If no troops in range, target towers
                target = findNearestEnemyTower(unit, towers, opponentPrefix, unit.targetLane);
                targetType = 'tower';
            }
        } else if (unit.behavior === 'defensive_building') {
            target = findNearestEnemyTroop(unit, units);
            targetType = 'troop';
        } else if (unit.behavior === 'building_targeting') {
            target = findNearestEnemyTower(unit, towers, opponentPrefix, unit.targetLane);
            targetType = 'tower';
        } else if (unit.behavior === 'ground_melee') {
            const nearbyTroop = findNearestEnemyTroop(unit, units);
            if (nearbyTroop && nearbyTroop.distance < 15) {
                target = nearbyTroop; targetType = 'troop';
            } else {
                target = findNearestEnemyTower(unit, towers, opponentPrefix, unit.targetLane);
                targetType = 'tower';
            }
        }

        // ---- Movement ----
        if (unit.isMoving && unit.speed && target && target.x !== undefined) {
            const dx = target.x - unit.x;
            const dy = target.y - unit.y;
            const distance = Math.sqrt(dx * dx + dy * dy) || 1;
            const inRange = distance < (unit.attackRange || 3);

            // ranged units stop when in range
            if (unit.behavior === 'ranged_attacker') {
                if (!inRange) {
                    unit.x += (dx / distance) * unit.speed * 0.3;
                    unit.y += (dy / distance) * unit.speed * 0.3;
                }
            } else {
                if (!inRange) {
                    unit.x += (dx / distance) * unit.speed * 0.5;
                    unit.y += (dy / distance) * unit.speed * 0.5;
                }
            }
        }

        // ---- Attack ----
        if (target && (now - (unit.lastAttackTime || 0)) > (unit.attackSpeed || 1000)) {
            if (targetType === 'troop' && target.distance < (unit.attackRange || 6)) {
                if (unit.behavior === 'ranged_attacker') {
                    spawnArrow(unit, target);  // Fire projectile
                    unit.lastAttackTime = now;
                } else {
                    const targetUnitId = target.id;
                    const targetUnit = localUnits[targetUnitId];
                    if (targetUnit && targetUnit.hp > 0) {
                        targetUnit.hp = Math.max(0, targetUnit.hp - (unit.damage || 50));
                        unit.lastAttackTime = now;
                        if (targetUnit.hp <= 0) {
                            toRemove.push(targetUnitId);
                            // Gain XP for destroying enemy units
                            if (unit.owner === myPlayerID) {
                                gainXP(5);
                            }
                        }
                    }
                }
            } else if (targetType === 'tower' && target.distance < (unit.attackRange || 6)) {
                if (unit.behavior === 'ranged_attacker') {
                    spawnArrow(unit, target);  // Fire projectile at tower
                    unit.lastAttackTime = now;
                } else {
                    // Melee attack on tower
                    const towerId = target.towerId;
                    if (towers[towerId] > 0) {
                        towers[towerId] = Math.max(0, towers[towerId] - (unit.damage || 50));
                        unit.lastAttackTime = now;
                    }
                }
            }
        }
    });

    toRemove.forEach(id => delete localUnits[id]);
};

// ---------- Update tower display for local simulation ----------
const updateTowerDisplay = () => {
    const towerElements = {
        'playerA-king': 'tower-player-king',
        'playerA-left': 'tower-player-left', 
        'playerA-right': 'tower-player-right',
        'playerB-king': 'tower-opponent-king',
        'playerB-left': 'tower-opponent-left',
        'playerB-right': 'tower-opponent-right'
    };
    
    Object.keys(towerElements).forEach(towerId => {
        const elementId = towerElements[towerId];
        const element = document.getElementById(elementId);
        if (element && towers[towerId] !== undefined) {
            element.textContent = Math.ceil(towers[towerId]);
            if (towers[towerId] <= 0) {
                element.textContent = 'ðŸ’€';
                element.parentElement.style.opacity = '0.3';
            }
        }
    });
};

// ---------- Arrow projectile visual + damage ----------
const spawnArrow = (unit, target) => {
    const arenaMap = document.getElementById('arenaMap');
    if (!arenaMap) return;

    // Create a bright glowing arrow projectile
    const arrow = document.createElement('div');
    arrow.style.position = 'absolute';
    arrow.style.width = '14px';
    arrow.style.height = '14px';
    arrow.style.borderRadius = '50%';
    arrow.style.background = 'linear-gradient(135deg, #ffff66, #ffcc00)';
    arrow.style.boxShadow = '0 0 10px 3px rgba(255, 255, 100, 0.9)';
    arrow.style.left = `${unit.x}%`;
    arrow.style.top = `${unit.y}%`;
    arrow.style.transform = 'translate(-50%, -50%)';
    arrow.style.transition = 'all 0.4s linear';
    arrow.style.zIndex = 9999; // ensure it's above everything
    arenaMap.appendChild(arrow);

    // Animate arrow toward target
    requestAnimationFrame(() => {
        arrow.style.left = `${target.x}%`;
        arrow.style.top = `${target.y}%`;
    });

    // Apply damage and remove arrow after travel
    setTimeout(() => {
        arrow.remove();
        if (target.id && localUnits[target.id]) {
            // Target is a unit
            const targetUnit = localUnits[target.id];
            if (targetUnit && targetUnit.hp > 0) {
                targetUnit.hp = Math.max(0, targetUnit.hp - (unit.damage || 60));
                if (targetUnit.hp <= 0) {
                    delete localUnits[target.id];
                    // Gain XP for destroying enemy units
                    if (unit.owner === myPlayerID) {
                        gainXP(5);
                    }
                }
            }
        } else if (target.towerId) {
            // Target is a tower
            const towerId = target.towerId;
            if (towers[towerId] > 0) {
                towers[towerId] = Math.max(0, towers[towerId] - (unit.damage || 60));
                // Update tower display
                updateTowerDisplay();
                
                // Check for tower destruction
                if (towers[towerId] <= 0) {
                    // Clear manual targets for this tower
                    Object.keys(localUnits).forEach(unitId => {
                        const u = localUnits[unitId];
                        if (u && u.manualTarget && u.manualTarget.towerId === towerId) {
                            u.manualTarget = null;
                        }
                    });
                    
                    // Clear tower targeting visual
                    const towerElementId = towerId.replace('playerB-', 'tower-opponent-');
                    const towerElement = document.getElementById(towerElementId);
                    if (towerElement) {
                        towerElement.classList.remove('targeted');
                    }
                }
            }
        }
    }, 400);
};

        // ---------- Target finding helpers (works with both localUnits and Firebase unit objects) ----------
        const findNearestEnemyTroop = (unit, units) => {
            let nearest = null; let minDist = Infinity;
            Object.keys(units).forEach(targetId => {
                const target = units[targetId]; if (!target) return; if (target.owner !== unit.owner && target.hp > 0) {
                    const dx = target.x - unit.x; const dy = target.y - unit.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < minDist) { minDist = dist; nearest = { ...target, id: targetId, x: target.x, y: target.y, distance: dist }; }
                }
            });
            return nearest;
        };

        const findNearestEnemyTower = (unit, towers, opponentPrefix, targetLane) => {
            const towerPositions = { 'left': { x: 15, y: 16 }, 'right': { x: 85, y: 16 }, 'king': { x: 50, y: 10 } };
            let targetTowerId = null;
            if (targetLane === 'left' && towers[`${opponentPrefix}-left`] > 0) targetTowerId = `${opponentPrefix}-left`;
            else if (targetLane === 'right' && towers[`${opponentPrefix}-right`] > 0) targetTowerId = `${opponentPrefix}-right`;
            else {
                if (towers[`${opponentPrefix}-left`] > 0) targetTowerId = `${opponentPrefix}-left`;
                else if (towers[`${opponentPrefix}-right`] > 0) targetTowerId = `${opponentPrefix}-right`;
                else if (towers[`${opponentPrefix}-king`] > 0) targetTowerId = `${opponentPrefix}-king`;
            }
            if (!targetTowerId) return null; const towerSide = targetTowerId.split('-')[1]; const towerPos = towerPositions[towerSide]; const dx = towerPos.x - unit.x; const dy = towerPos.y - unit.y; const dist = Math.sqrt(dx*dx + dy*dy);
            return { x: towerPos.x, y: towerPos.y, distance: dist, towerId: targetTowerId };
        };

        // ---------- Ending & returning ----------
        const endGame = (message, isVictory) => {
            if (elixirInterval) clearInterval(elixirInterval); if (gameTickInterval) clearInterval(gameTickInterval);
            matchesRef.off(); gameListenerActive = false;
            
            if (isVictory) { 
                playerData.wins++; 
                playerData.trophies += 30; 
                playerData.coins += 50;
                gainXP(50); // Victory XP reward
            }
            else if (message.includes('Defeat')) { 
                playerData.losses++; 
                playerData.trophies = Math.max(0, playerData.trophies - 10);
                gainXP(10); // Small XP reward even for defeat
            }
            else {
                gainXP(5); // Small XP for other endings (forfeit, timeout)
            }
            
            savePlayerData(); 
            alert(message);
            if (currentMatchID) { matchesRef.child(currentMatchID).remove().then(returnToMenu); } else { returnToMenu(); }
        };

        const returnToMenu = () => {
            currentMatchID = null; selectedCard = null; if (elixirInterval) clearInterval(elixirInterval); if (gameTickInterval) clearInterval(gameTickInterval); matchesRef.off(); bottomNav.style.display = 'flex'; localUnits = {}; // clear local test units
            mainContent.innerHTML = `
                <div class="arena-info"><h2>Royal Arena</h2><p>Welcome to the battlefield!</p></div>
                <button id="battleButton" class="battle-button battle-tab-button"><i class="fas fa-swords"></i> Battle!</button>
            `; setupButtonListeners(); navButtons.forEach(btn => btn.classList.remove('active')); document.querySelector('.nav-button[data-content="battle"]').classList.add('active');
        };

        // ---------- Match creation / matchmaking ----------
        const finalizeMatch = (opponentID) => {
            const newMatchRef = matchesRef.push(); const matchID = newMatchRef.key;
            const matchData = { playerA: myPlayerID, playerB: opponentID, status: 'active', created: firebase.database.ServerValue.TIMESTAMP, startTime: Date.now(), towers: {'playerA-king':2534,'playerA-left':1420,'playerA-right':1420,'playerB-king':2534,'playerB-left':1420,'playerB-right':1420}, units: {} };
            const updates = {}; updates[`/matches/${matchID}`] = matchData; updates[`/matchmaking/${myPlayerID}`] = null; updates[`/matchmaking/${opponentID}`] = null;
            firebase.database().ref().update(updates).then(() => { startGameView(matchID, myPlayerID, opponentID); }).catch(error => { console.error("Error finalizing match:", error); alert("Failed to start match."); });
        };

        const searchForOpponent = () => {
            const battleButton = document.getElementById('battleButton'); if (!battleButton) return; battleButton.innerText = "Searching..."; battleButton.disabled = true;
            matchmakingRef.limitToFirst(2).once('value', snapshot => {
                let opponentID = null; snapshot.forEach(childSnapshot => { if (childSnapshot.key !== myPlayerID) { opponentID = childSnapshot.key; return true; } });
                if (opponentID) finalizeMatch(opponentID); else {
                    const playerEntry = { timestamp: firebase.database.ServerValue.TIMESTAMP, status: 'searching' };
                    matchmakingRef.child(myPlayerID).set(playerEntry).then(() => { matchmakingRef.child(myPlayerID).onDisconnect().remove(); matchesRef.orderByChild('playerB').equalTo(myPlayerID).limitToLast(1).once('child_added', snapshot => { if (snapshot.exists()) { const matchData = snapshot.val(); matchesRef.off('child_added'); startGameView(snapshot.key, matchData.playerA, matchData.playerB); } }); });
                }
            });
        };

        // ---------- Simple Lobby System ----------
        const renderLobby = () => {
            return `
                <div class="lobby-container">
                    <div class="lobby-section">
                        <h3><i class="fas fa-gamepad"></i> Join Match</h3>
                        <div class="join-match">
                            <h4>Enter Match Name to Join</h4>
                            <div class="input-group">
                                <input type="text" id="joinMatchName" placeholder="Type match name to join..." maxlength="20">
                                <button class="battle-button battle-tab-button" id="joinMatchBtn">
                                    <i class="fas fa-play"></i> Join Match
                                </button>
                            </div>
                            <p class="help-text">If the match doesn't exist, it will be created automatically.</p>
                        </div>
                    </div>
                    
                    <div class="lobby-section">
                        <h3><i class="fas fa-list"></i> Active Matches</h3>
                        <div class="active-matches">
                            <div id="activeMatchesList" class="matches-list">
                                <div class="loading">Loading active matches...</div>
                            </div>
                            <button id="refreshMatchesBtn" class="refresh-btn">
                                <i class="fas fa-sync-alt"></i> Refresh
                            </button>
                        </div>
                    </div>
                </div>
            `;
        };

        // ---------- Lobby Functions ----------
        const joinOrCreateMatch = () => {
            const matchName = document.getElementById('joinMatchName').value.trim();
            
            if (!matchName) {
                alert('Please enter a match name!');
                return;
            }
            
            console.log('Looking for match:', matchName);
            
            // First, try to find an existing match with this name
            lobbiesRef.orderByChild('name').equalTo(matchName).once('value').then(snapshot => {
                let existingMatch = null;
                snapshot.forEach(childSnapshot => {
                    const lobby = childSnapshot.val();
                    if (lobby && lobby.status === 'waiting') {
                        existingMatch = { id: childSnapshot.key, ...lobby };
                        return true; // Stop after first match
                    }
                });
                
                if (existingMatch) {
                    console.log('Found existing match, joining...');
                    joinExistingMatch(existingMatch);
                } else {
                    console.log('No existing match found, creating new one...');
                    createNewMatch(matchName);
                }
            }).catch(error => {
                console.error('Error searching for match:', error);
                alert('Error searching for match. Please try again.');
            });
        };

        const joinExistingMatch = (match) => {
            const playerCount = Object.keys(match.players || {}).length;
            
            if (playerCount >= 2) {
                alert('This match is full!');
                return;
            }
            
            // Check if player is already in this match
            if (match.players && match.players[myPlayerID]) {
                alert('You are already in this match!');
                return;
            }
            
            const playerInfo = {
                name: myPlayerName,
                level: playerData.level,
                joined: Date.now()
            };
            
            lobbiesRef.child(`${match.id}/players/${myPlayerID}`).set(playerInfo).then(() => {
                console.log('Joined existing match:', match.name);
                checkIfMatchReady(match.id);
            }).catch(error => {
                console.error('Error joining match:', error);
                alert('Failed to join match. Please try again.');
            });
        };

        const createNewMatch = (matchName) => {
            const lobbyData = {
                name: matchName,
                host: myPlayerID,
                hostName: myPlayerName,
                status: 'waiting',
                created: Date.now(),
                players: {
                    [myPlayerID]: {
                        name: myPlayerName,
                        level: playerData.level,
                        joined: Date.now()
                    }
                }
            };
            
            const newLobbyRef = lobbiesRef.push();
            newLobbyRef.set(lobbyData).then(() => {
                console.log('Created new match:', matchName);
                checkIfMatchReady(newLobbyRef.key);
            }).catch(error => {
                console.error('Error creating match:', error);
                alert('Failed to create match. Please try again.');
            });
        };

        const checkIfMatchReady = (lobbyId) => {
            lobbiesRef.child(lobbyId).once('value').then(snapshot => {
                const lobby = snapshot.val();
                if (!lobby) return;
                
                const players = Object.keys(lobby.players || {});
                console.log('Players in match:', players.length);
                
                if (players.length >= 2) {
                    startMatch(lobbyId, lobby);
                } else {
                    alert('Waiting for another player to join...');
                    loadActiveMatches();
                }
            });
        };

        const startMatch = (lobbyId, lobby) => {
            const players = Object.keys(lobby.players || {});
            
            const matchData = {
                playerA: players[0],
                playerB: players[1],
                status: 'active',
                created: Date.now(),
                startTime: Date.now(),
                lobbyId: lobbyId,
                towers: {
                    'playerA-king': 2534, 'playerA-left': 1420, 'playerA-right': 1420,
                    'playerB-king': 2534, 'playerB-left': 1420, 'playerB-right': 1420
                },
                units: {}
            };
            
            const newMatchRef = matchesRef.push();
            newMatchRef.set(matchData).then(() => {
                // Update lobby status
                lobbiesRef.child(lobbyId).update({ status: 'in-progress' });
                
                // Start the game
                startGameView(newMatchRef.key, players[0], players[1]);
            }).catch(error => {
                console.error('Error starting match:', error);
                alert('Failed to start match. Please try again.');
            });
        };

        const loadActiveMatches = () => {
            const matchesList = document.getElementById('activeMatchesList');
            if (!matchesList) return;
            
            matchesList.innerHTML = '<div class="loading">Loading active matches...</div>';
            
            lobbiesRef.orderByChild('status').equalTo('waiting').once('value').then(snapshot => {
                const matches = [];
                snapshot.forEach(childSnapshot => {
                    const lobby = childSnapshot.val();
                    if (lobby) {
                        matches.push({
                            id: childSnapshot.key,
                            ...lobby
                        });
                    }
                });
                
                displayActiveMatches(matches);
            }).catch(error => {
                console.error('Error loading matches:', error);
                matchesList.innerHTML = '<div class="no-matches">Error loading matches</div>';
            });
        };

        const displayActiveMatches = (matches) => {
            const matchesList = document.getElementById('activeMatchesList');
            if (!matchesList) return;
            
            if (matches.length === 0) {
                matchesList.innerHTML = '<div class="no-matches">No active matches</div>';
                return;
            }
            
            matchesList.innerHTML = matches.map(match => {
                const playerCount = Object.keys(match.players || {}).length;
                const isInMatch = match.players && match.players[myPlayerID];
                
                return `
                    <div class="match-item ${isInMatch ? 'your-match' : ''}">
                        <div class="match-info">
                            <h5>${match.name}</h5>
                            <p>Players: ${playerCount}/2</p>
                            <p>Host: ${match.hostName}</p>
                        </div>
                        <div class="match-actions">
                            ${isInMatch ? 
                                '<span class="in-match">You are in this match</span>' : 
                                (playerCount < 2 ? 
                                    `<button class="join-button" onclick="joinMatchByName('${match.name}')">Join</button>` : 
                                    '<span class="full-match">Full</span>'
                                )
                            }
                        </div>
                    </div>
                `;
            }).join('');
        };

        const joinMatchByName = (matchName) => {
            document.getElementById('joinMatchName').value = matchName;
            joinOrCreateMatch();
        };


        const setupLobbyListeners = () => {
            // Join match button
            const joinBtn = document.getElementById('joinMatchBtn');
            if (joinBtn) {
                joinBtn.addEventListener('click', joinOrCreateMatch);
            }
            
            // Join match input (Enter key)
            const joinInput = document.getElementById('joinMatchName');
            if (joinInput) {
                joinInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        joinOrCreateMatch();
                    }
                });
            }
            
            // Refresh button
            const refreshBtn = document.getElementById('refreshMatchesBtn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', loadActiveMatches);
            }
            
            // Clean up old test matches
            console.log('Cleaning up old test matches...');
            lobbiesRef.once('value').then(snapshot => {
                snapshot.forEach(childSnapshot => {
                    const lobby = childSnapshot.val();
                    if (lobby && (lobby.name === 'Simple Test' || lobby.name === 'Debug Test Match' || lobby.status === 'in-progress')) {
                        console.log('Removing old test match:', childSnapshot.key, lobby.name);
                        childSnapshot.ref.remove();
                    }
                });
                
                // Load active matches
                loadActiveMatches();
            });
        };

        // ---------- Cards collection view ----------
        const renderCardsCollection = () => {
            const allCards = Object.keys(CARDS).map(id => ({ id, ...CARDS[id] }));
            const xpNeeded = getXpForLevel(playerData.level);
            const xpProgress = (playerData.xp / xpNeeded) * 100;
            const levelTitle = getLevelTitle(playerData.level);
            
            return `
                <div class="arena-info">
                    <h2>Card Collection</h2>
                    <p>Level ${playerData.level} - ${levelTitle}</p>
                    <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>XP: ${playerData.xp} / ${xpNeeded}</span>
                            <span>Total XP: ${playerData.totalXp}</span>
                        </div>
                        <div style="width: 100%; height: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;">
                            <div style="height: 100%; background: linear-gradient(90deg, #4ecdc4, #44a08d); width: ${xpProgress}%; transition: width 0.5s ease;"></div>
                        </div>
                    </div>
                </div>
                <div class="cards-grid">
                    ${allCards.map(card => { const isUnlocked = playerData.unlockedCards.includes(card.id); return `
                        <div class="card-detail ${isUnlocked ? '' : 'locked'}">
                            <div class="card-detail-icon">${card.icon}</div>
                            <div class="card-detail-name">${card.name}</div>
                            <div class="card-detail-cost">${card.cost} <i class="fas fa-flask"></i></div>
                            <div class="card-detail-desc">${card.desc}</div>
                            <div class="card-detail-stats">${card.hp ? `HP: ${card.hp}<br>` : ''}DMG: ${card.damage}${card.speed ? `<br>Speed: ${card.speed}x` : ''}</div>
                            ${!isUnlocked ? `<div class="unlock-requirement">ðŸ”’ Unlock at Level ${card.unlockLevel}</div>` : ''}
                        </div>
                    `; }).join('')}
                </div>
            `;
        };

        const setupButtonListeners = () => { const battleButton = document.getElementById('battleButton'); if (battleButton) battleButton.onclick = searchForOpponent; };

        navButtons.forEach(button => { button.addEventListener('click', () => {
            const contentKey = button.getAttribute('data-content'); navButtons.forEach(btn => btn.classList.remove('active')); button.classList.add('active'); matchesRef.off(); matchmakingRef.child(myPlayerID).onDisconnect().cancel(); gameListenerActive = false; if (elixirInterval) clearInterval(elixirInterval); if (gameTickInterval) clearInterval(gameTickInterval);
            let newHTML = '';
            if (contentKey === 'battle') {
                newHTML = `<div class="arena-info"><h2>Royal Arena</h2><p>Welcome to the battlefield!</p></div><button id="battleButton" class="battle-button battle-tab-button"><i class="fas fa-swords"></i> Battle!</button>`;
                setupButtonListeners();
            } else if (contentKey === 'lobby') {
                newHTML = renderLobby();
                setupLobbyListeners();
            } else if (contentKey === 'cards') {
                newHTML = renderCardsCollection();
            } else {
                newHTML = `<div class="arena-info"><h2>${contentKey.toUpperCase()}</h2><p>Coming soon...</p></div>`;
            }
            mainContent.innerHTML = newHTML; }); });

        loadPlayerData(); setupButtonListeners();
    </script>
</body>
</html>